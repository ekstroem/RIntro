# (APPENDIX) Appendiks {-} 

# Introduktion til R {#Rintro}

R er et program og programmeringssprog designet til statistiske udregninger og grafik.^[R kan hentes fra 
`www.r-project.org`.  Fra hjemmesiden vælges først download (CRAN),
derefter en server, hvorefter man kan hente og
installere R.] Vi bruger R, fordi det er *de facto* standarden
indenfor statistisk software, fordi det gør det let at reproducere
sine resultater, og fordi R nyder godt af et stort og dynamisk
brugermiljø. Det betyder, at mange nyudviklede visualiserings- og analysemetoder
publiceres med kode til R, så alle brugere kan anvende disse nye
metoder uden at skulle programmere dem selv.

```{r echo=FALSE, fig.margin=TRUE}
knitr::include_graphics("pics/Rlogo.png")
```

R fungerer ved at skrive kommandoer til programmet, som så udføres, og
så snart man er fortrolig med programmet har man adgang til et af de
stærkeste statistiske analyseværktøjer, der findes.

## RStudio

Programmet RStudio udvider R og gør det lettere at arbejde med R.
RStudio fungerer som editor, gør det nemt at lave reproducerbar
forskning, håndtere grafik og giver let adgang til Rs hjælpesider. Det
anbefales at installere RStudio, og når både R og RStudio er
installeret kan man nøjes med at starte RStudio.^[RStudios hjemmeside
er `www.rstudio.com` og herfra kan man downloade RStudio.]

RStudio er inddelt i fire mindre vinduer (se figur
\@ref(fig:rstudio-ide)). Øverste venstre vindue er en teksteditor,
hvor man skriver sine R kommandoer.^[Kommandoerne i
RStudios editor kan gemmes som dokumentation for de
analyser, der er lavet.  Filer med kommandoer til R har typisk
efternavnet `.R` eller `.r`, men det er bare helt almindelige
tekstfiler.\index{filtyper|.R} Det anbefales at skrive alle
kommandoerne i editoren, da det sikrer, at det er muligt at
reproducere og genskabe alle resultater.] Kommandoerne i editoren
udføres først, når man trykker "Run" på menubjælken (så bliver alle
kommandoerne i editoren udført i rækkefølge), eller alternativt vil
\keys{\ctrl + \return} (\keys{\cmd + \return} på Mac) udføre
kodelinjen, som cursoren står på i editoren. Markeres flere linjer
sendes de alle til R og eksekveres i rækkefølge.

```{r rstudio-ide, echo=FALSE, fig.cap="RStudios brugergrænseflade er inddelt i 4 mindre vinduer: Øverst til venstre findes editoren, hvor man kan skrive, gemme og hente sit R program. Nederst til venstre er konsollen, hvor man har direte adgang til R, og hvor resultatet af udregningerne vises. Øverst til højre vises det nuværende workspace og historikken, og nederst til højre findes en filoversigt, og det er også her grafik, figurer og hjælpesider bliver vist.", out.width="100%", fig.fullwidth=TRUE}
knitr::include_graphics('pics/rstudio-boxes.png', dpi = NA)
```

I nederste venstre vindue af RStudio findes konsollen, hvor selve R
kører. Her vises er resultatet af udregningerne. Når kommandoer
overføres fra editorvinduet som beskrevet ovenfor, så bliver de i
praksis kopieret ned i konsollen linje for linje. 

Øverste højre vindue viser Rs workspace --- en oversigt over objekterne
i Rs hukommelse. Fanebladet "History" viser
historikken over alle de kommandoer, der hidtil har været udført af
R. Markerer man en eller flere af linjerne i historikken og
dobbeltklikker på dem, så sendes de direkte til konsollen og bliver
kørt igen. Det er også muligt at gemme hele historikken i en fil, så
man den vej igennem kan dokumentere og genskabe de kommandoer, der har
været kørt.

Tegninger og grafik bliver vist nederst til
højre, og herfra er det også muligt at eksportere figurer, så de kan anvendes i andre
programmer. Beder man R om hjælp bliver det også vist i nederste højre
vindue, og det er også her, at man finder en oversigt over filerne i
det bibliotek, hvor R arbejder lige nu.^[Opgave XXX viser, hvordan man
skifter arbejdsbibliotek.]


### Tricks når man arbejder med R

Der er en række tricks, der er værd at kende, når man arbejder med R.

*   I konsollen viser R en prompt, `>`, når programmet er klar til at
    modtage kommandoer. Får man ikke færdiggjort en kommando skifter
    prompten til `+` og man har mulighed for at færdiggøre ordren.
    \keys{esc} afbryder ordren og man kommer tilbage til `>`.

*   I konsollen vil \keys{\arrowkeyup} og \keys{\arrowkeydown} bladre op
     og ned i gamle kommandoer.  Så slipper man for at skulle skrive
     gamle kommandoer helt forfra.

*   Funktioner i R angives altid med parenteser og har formen
    `funktionsnavn(argument1, argument2, ...)`, hvor det er muligt at give
    nul eller flere argumenter afhængigt af den konkrete funktion. På den
    måde kan man altid skelne mellem almindelige objekter og
    funktioner.^[Hvis man skriver navnet på en funktion *uden* at angive
    parenteser så vises koden, som funktionen udfører. På
    den måde kan man direkte se, hvad de forskellige funktioner i R
    faktisk gør.]

RStudio gør det utrolig let at arbejde med R, da RStudio har
"auto-completion"\index{auto-completion}: når man starter med at taste
i editoren eller konsollen foreslår RStudio, hvad der kunne stå,
hvilket reducerer risikoen for tastefejl. Hvis man trykker \keys{tab}
færdiggør RStudio resten af navnet på det objekt/den funktion, som man er
startet med at skrive.


## R som lommeregner {#R-lommeregner}

R fungerer som en helt almindelig lommeregner. Taster man et
regneudtryk ind i editoren (øverste venstre vindue), markerer det, og
trykker \keys{\ctrl + \return} (\keys{\cmd + \return} på Mac) så bliver koden
automatisk kopieret ned i konsollen og kørt.

```{r}
1 + 5   # Dette er en kommentar: udregn 1 + 5
```

Alt efter `#` opfattes som en kommentar, så man kan skrive noter efter
hver kommando, for senere at huske, hvad den gør. Svaret på 5+1 aflæses til 
6.^[Foran resultatet står et `[1]`, som vi kan ignorere indtil
videre. Forklaringen kommer i afsnit \@ref(R-vector).]

De fire almindelige regnearter: `+`, `-`, `*` og `/` fungerer som
normalt ligesom `^` (opløftning i potens) samt naturligvis
parenteser.

```{r}
3 * (1 + 5) / (4 + 2^2)   # Langt regneudtryk
```

Udregningen af $\frac{3\cdot(1+5)}{4 + 2^2}$ er 2.25.

Resultatet af en udregning kan gemmes i et objekt, så de kan
genbruges. R bruger "pilen" `<-` til at gemme et objekt.^[
Pilen består af to tegn: `<` (mindre end) og `-` (minus). Pilen `<-`
kan opfattes som om, at man sender resultatet over i det
valgte objekt.] Navnet på det gemte objekt kan vælges næsten frit:
det skal dog starte med et bogstav og må ikke indeholde `+`, `-`, `*`,
`/`, `^`, `;`, `(`, `)` og komma.


```{r}
y <- 5   # Gem værdien 5 i variablen y
y        # Udskriv værdien af y
y * 2    # Udregn 2 * værdien af indholdet af y
```

Mere komplicerede matematiske operationer kan udregnes ved hjælp af funktionerne vist i tabel
\@ref(tab:mathfunctions).

Table: (\#tab:mathfunctions) De mest almindelig matematiske funktioner i R.

|   Funktion |   Forklaring |    Eksempel |
|------------|--------------|-------------|
|   `abs(x)`  | Numerisk (absolut) værdi\index{absolut værdi}\index{numerisk værdi}| `abs(-3) = 3` |
|   `sqrt(x)` | Kvadratrod\index{kvadratrod} | `sqrt(9) = 3` |
| `a^x` | $a$ i $x$te potens\index{potens} | `4^2 = 16` |
|   `log(x)`  | Naturlig logaritme\index{ln}\index{naturlig logaritme}\index{logaritme!naturlig} | `log(10) = 2.303` |
|   `log10(x)`  | Titalslogaritme\index{titalslogaritme}\index{logaritme!titals} | `log10(10) = 1` |
|   `log(x, base=2)`  | Totalslogaritme\index{logaritme!totals} | `log(10, base=2) = 3.322` |
|   `exp(x)`  | Eksponentialfunktionen\index{eksponentialfunktionen} | `exp(1) = 2.718` |




R skelner mellem store og små bogstaver, så `Y` og `y` er to
forskellige objekter, hvilket kan give anledning til overraskelser,
hvis man ikke er opmærksom på det.^[På samme vis er funktionen `log()` ikke det samme som funktionen `LOG()` eller `Log()`.]


```{r error=TRUE}
Y        # Et ukendt objekt
```


R indeholder en ret veludbygget dokumentation, og hjælpesiden til 
en specifik funktion eller et datasæt kan ses med
funktionen `help()`.

```{r eval=FALSE}
help(sqrt)   # Hent hjælpesiden for funktionen sqrt
```

Ovennævnte henter hjælpesiderne for `sqrt()` frem og viser en grundig
forklaring af funktionen og dens tilhørende argumenter.

Kender man ikke kender navnet på den R funktion, man ønsker at bruge,
kan `help.search()` søge hjælpesiderne igennem.^[Internettet er en
rig ressource til at søge efter hjælp til R. Der er tusindevis af sider med
hjælp, eksempler, forklaringer og videoer.]

```{r eval=FALSE}
help.search("box plot")   # Find funktioner om "box plot"
```

Dette viser en liste over de funktioner, hvor der står noget om
"box plot", hvilket giver en ide om, hvilke funktioner man skal lede efter.


## Vektorer {#R-vector}

Vektorer er en af Rs helt store styrker. En vektor er en samling
af elementer af samme type --- eksempelvis tal eller tekst.

En vektor kan laves ved at bruge funktionen `c()` (for
combine eller concatenate) til at "klistre" elementer sammen.

```{r}
hojde <- c(1.65, 1.79, 1.62, 1.87)  # Højde for 4 patienter
hojde                               # Udskriv højderne
vaegt <- c(55.2, 89.7, 49.8, 92.1)  # Vægt for samme 4 personer
vaegt                               # Udskriv vægtene
```

Fordelen ved vektorer er, at R kan lave samme udregning for hvert
enkelt element i vektoren. Body-mass index (BMI)^[Body-mass index er
defineret som en persons vægt (målt i kg) delt med højde (målt i meter) kvadreret.]
for alle fire personer udregnes ved

```{r}
bmi <- vaegt / (hojde^2)   # Udregn BMI og gem som bmi
bmi                        # Udskriv bmi
```

hvilket direkte giver resultaterne for alle fire patienter. Bemærk, at
R regner elementvis, så det første element i `hojde` bruges sammen med
det første element i `vaegt` og så videre. Rækkefølgen på målingerne
er altså vigtig og skal passe sammen.

Hvis vektorerne i en udregning ikke har samme længde, så undersøger R
først, om længden af den korte vektor går op i længden af den lange
vektor.\index{recycling} Hvis det er tilfældet bliver den korte vektor gentaget indtil
den har samme længde som den lange vektor.^[Hvis længden af den korte
vektor *ikke* går op i længden af den lange vektor så bliver den korte
vektor stadig gentaget indtil den matcher længden af den lange, men en
advarsel skrives på skærmen.] Hvis vi eksempelvis hellere ville have
målt højderne i cm i stedet for i meter så skal vi gange alle
værdierne med 100.\index{recycling}

```{r}
hojde * 100   # Gang hver enkelt højdeværdi med 100
```

Denne udregning går godt, fordi `hojde` er en vektor af længde 4, og tallet 
`100` opfattes om en vektor af længde 1. Da 1 går op i 4 gentages
værdien `100` 4 gange indtil de to vektorer er lige lange, og så arbejder R
elementvis igen.

Vektorer er især nyttige i kombination med de indbyggede matematiske
funktioner, da disse accepterer vektorer som input. For eksempel vil
`log()` tage den naturlige logaritme af hvert element i en vektor.


```{r}
log(hojde)   # Tag logaritmen til hvert element i hojde
```

Nogle funktioner bruger hele vektoren til at udregne nye
resultater. Eksempelvis udregnes gennemsnittet af de fire personers
BMI ved at give vektoren til funktionen `mean()`.

```{r}
mean(bmi)   # Udregn gennemsnittet af alle værdierne i bmi
```

R deler outputtet op i flere linjer for lange lange vektorer, der ikke
kan udskrives på en enkelt linje. Input kan også splittes over flere
linjer. Så skifter Rs inputprompt midlertidigt fra `>` til `+` så det
er tydeligt, at man skriver videre på linjen ovenfor.


```{r}
langvektor <- c(1, 3, 5, 7, 9, 2, 4, 6, 8, 10, 20, 21, 22, 23,
                24, 25, 26, 27, 28, 29, 30, 100, 101, 102, 103,
                104, 105, 106, 107, 108, 109)
langvektor
```

\marginnote{Bemærk starten på de tre linjer i udskriften. I første
linje står der `[1]` --- som vi også tidligere har set --- mens der på
anden og tredie linje står henholdsvis `[14]` og `[27]`. Disse tal
hjælper til at læse udskriften, og viser, at den første værdi på
første linje er element nummer 1 i vores vektor. Den første værdi
på linje to er element nummer 14 i vores vektor, og det første tal på
linje 3 er element nummer 27. De resultater, der fremkom, da vi brugte
R som lommeregner, startede alle med `[1]`, hvilket viser, at R
automatisk opfattede resultatet som en vektor (som kun bestod af et
enkelt element).}

Vektorer behøver ikke indeholde tal, men kan for eksempel også bestå af 
tekst eller logiske værdier\index{logiske værdier} (sandt eller falsk --- benævnt `TRUE` eller
`FALSE` i R).


```{r}
v2 <- c("Bamse", "Kylling", "ælling") # En vektor af tekst
v3 <- c(TRUE, FALSE, FALSE)           # En logisk vektor
v4 <- c(1, 2, 5)                      # En vektor af tal
v2                                    # Udskriv v2
v3                                    # Udskriv v3
v4                                    # Udskriv v4
```


### Indicering i vektorer

Man kan henvise til specifikke elementer i en vektor med en anden vektor med de relevante indices i skarpe paranteser.

```{r}
v2[c(2, 3)]    # Udtræk element nummer 2 og 3 fra v2
```

Indicering kan også bruges til at ændre specifikke elementer.

```{r}
v2[3] <- "Ælling"   # Skift element 3 til at starte med stort
v2                  # Udskriv den nye v2
```

Ved indicering kommer elementerne ud i den rækkefølge de bliver
refereret, og man kan bytte rundt på elementernes rækkefølge ved at
ændre rækkefølgen på indices.

```{r}
v2[c(2, 3, 1)]      # Udskriv v2 i ny rækkefølge
```

Bemærk at `v2` ikke ændres i ovennævnte kommando, da kommandoen blot
udskriver en vektor, hvor der er byttet rundt på
rækkefølgen. Resultatet skal gemmes, hvis det skal bruges i en anden
sammenhæng:

```{r}
v5 <- v2[c(2, 3, 1)]  # Lav v5 med ny rækkefølge af v2
v5
```

En logisk vektor af samme længde som den oprindelige vektor kan også
bruges som indeks. Så udvælges netop de elementer, hvor den logiske
vektor er sand.

```{r}
v2[v3]   # Udskriv de elementer i v2, hvor v3 er sand
```

Denne funktionalitet er ekstra nyttig, hvis man gerne vil udvælge
elementer på baggrund af værdierne i en anden vektor. 

```{r}
v2[v4 < 5]   # Vælg værdier af v2, hvor v4 er mindre end 5
```

Element 1 og 2 er netop de tilfælde, hvor værdien af `v4` er mindre
end 5.

I R bruges en lidt speciel notation, hvis man vil vurdere om to
objekter er ens. Man skal bruge *to* lighedstegn for at sammenligne om
to objekter er ens.

```{r}
v2[v4==2]  # Udvælg når v4 er 2. Bemærk to lighedstegn!
```


## Data frames {#R-dataframes}

Data frames er Rs betegnelse for et datasæt, der indeholder en samling af
vektorer (variablene i datasættet), der alle har samme længde.
En data frame laves ved at sætte vektorer af samme længde sammen ved
hjælp af funktionen `data.frame()`, og det er muligt at give vektorerne
navne, når datasættet laves.

```{r rectdataframe, echo=FALSE, engine='tikz', out.width='90%', fig.ext=if (knitr:::is_latex_output()) 'pdf' else 'png', fig.width=10, fig.height=5, fig.cap='Man kan tænke på en data frame som et firkantet område af et regneark, hvor hver række svarer til en observation, en person eller en registrering, og hvor hver søjle svarer til en variabel.', engine.opts = list(template = "latex/tikz2pdf.tex"), fig.margin=TRUE}
\usetikzlibrary{arrows,backgrounds,decorations.pathreplacing}

\begin{tikzpicture}[darkstyle/.style={rectangle,fill=gray!40,minimum size=38}]

  \foreach \x in {0,...,4}
    \foreach \y in {0,...,6} 
       {\pgfmathtruncatemacro{\label}{\x - 5 *  \y +21}
       \node [darkstyle]  (\x\y) at (1.5*\x,1.5*\y) {};} 
  \node[rotate=90] at (-1.5, 3*1.5) {\LARGE Observationer};
  \node[] at (1.5*2, 1.5*7) {\LARGE Variable};
\end{tikzpicture}
```

```{r}
DF <- data.frame(navn=v2, bjørn=v3, v4) # Lav data frame
DF                                      # Udskriv data frame
```

Variablene i en data frame eksisterer kun inde i selve data framen,
hvilket er ret smart, da samme variabelnavn så kan benyttes i flere
forskellige data frames uden at de overskriver hinanden.

```{r tidy=FALSE}
DF2 <- data.frame(navn=c("Palle", "Polle", "Ruth"),
                  v4=c(1,2,3))
DF2  # Udskriv den nye data frame. Bemærk variablene navn og v4
DF   # Den gamle data frame. Har også variablene navn og v4
```

Da variable i en data frame kun kan ses i den data frame, hvor de
er defineret, er det nødvendigt at angive navnet på den relevante
data frame, når variablen bruges i andre sammenhænge. Eksempelvis ved
R ikke, om variablen `v4` henviser til den pågældende variabel i `DF`,
eller `v4` fra `DF2`. Referencer til variable inde i en data frame
opnås ved at bruge `$` mellem navnet på data framen og
variablen.^[`DF$v4` kan læses som "variabel `v4` fra `DF`", og
den adskiller sig fra `DF2$v4`, der er en helt anden vektor (dog med
samme navn), og som findes i data framen `DF2`.]

```{r}
DF$v4    # Hent v4 fra DF
DF2$v4   # Hent v4 fra DF2
```

Nye variable kan tilføjes til en eksisterende data frame ved bare at
definere til den nye variabel. Eneste krav er, at den
nye variabel skal have samme længde som de øvrige variable.^[Eller
også skal længden på den korte vektor gå op i længden på de øvrige
variable i data framen så den kan gentages til at have samme længde.]

```{r}
DF$sko <- c("ja", "nej", "nej")  # Lav variabel sko i DF
DF
```


### Indicering i data frames

Data frames kan opfattes som firkantede regneark (se figur
\@ref(fig:rectdataframe)), og man kan referere til specifikke
elementer ved at bruge to indices svarende til rækker og søjler.

```{r}
# Hent anden observation fra tredie variabel
# svarende til række 2 søjle 3 i DF
DF[2, 3]
```

Hele rækker og søjler udtrækkes ved at undlade at angive værdier
for henholdsvis søjler og rækker.

```{r}
DF[3,]       # Hent hele række 3
DF[,c(2, 4)] # Hent søjler 2 og 4
```

Ligesom for vektorer kan indicering bruges til at indsætte nye
værdier for enkeltobservationer, rækker eller søjler.

```{r}
DF$v4[1] <- 10                 # Sæt første element af v4 i DF til 10
DF[,2] <- c(TRUE, TRUE, FALSE) # Erstat hele 2. søjle
DF                             # Udskriv data framen
```

Datasæt, der er del af R eller en R pakke (se afsnit \@ref(Rpakker)),
gøres tilgængelige med kommandoen `data()`. Hvis data ligger
i en pakke skal pakken først indlæses (se afsnit \@ref(Rpakker)).

```{r}
data(women)   # Indlæs datasættet women
head(women)   # Vis de første 6 linjer
```

## Tabeller og matricer {#R-matricer}

En matrix er en "firkantet samling" af tal, hvilket kan bruges til at
repræsentere antalstabeller\index{antalstabel}.^[Data frames og
matricer er begge rektangulære strukturer, men matricer kan kun
indeholde tal. I en matrix er der til gengæld ikke nogen typeforskel på
rækker og søjler.] I R bruges `matrix()` til at lave en matrix, og man
giver den en vektor af tal, der skal fyldes i matricen og fortæller,
hvor mange rækker, der skal være.

```{r}
m <- matrix(c(1, 2, 3, 4, 5, 6), 2) # Lav matrix med 2 rækker
m
```

Det sidste tal, 2, i kaldet til `matrix()` ovenfor bestemmer antallet
af rækker, som tallene skal fyldes ind i. Bemærk at matricen fyldes op
søjlevis.^[Med argumentet `byrow=TRUE` til `matrix()` vil matricen
blive fyldt op rækkevis i stedet for søjlevis.] Hvis antallet af
rækker ikke går op i antallet af tal i vektoren, så genbruger R
vektoren indtil den gør, og skriver en advarsel.


```{r}
m <- matrix(c(1, 2, 3, 4, 5), 2) # Matrix med for få tal
m
```

De fem første elementer i matricen fyldes op med værdierne 1 til
5, hvorefter R genbruger vektoren forfra, så det sidste element bliver 1.

Matricer indiceres på samme måde som data frames. Elementet i 1. række og 3. søjle er

```{r}
m[1, 3]
```


## Installation og brug af pakker {#Rpakker}

Der findes mere end 15000 pakker, som udvider R med nye funktioner og
datasæt. I RStudio kan nye pakker installeres via menupunktet `Tools >
Install Packages` (se figur \@ref(fig:rstudio-install-packages), hvor
pakken `isdals` installeres). Alternativt kan en pakke installeres
direkte i R med funktionen `install.packages()`.

```{r, eval=FALSE}
install.packages("isdals")   # Installér pakken isdals
```

```{r rstudio-install-packages, echo=FALSE, fig.cap="Installation af nye pakker gennem RStudios brugergrænseflade foregår via menupunktet `Tools > Install Packages`. Her installeres pakken `isdals` fra CRAN, der er Rs officielle netværk af tilgængelige pakker.", out.width=figoutwidth}
knitr::include_graphics('pics/rstudio-install-packages.png', dpi = NA)
```

Det er kun nødvendigt at installere en pakke én gang.  For at *bruge*
funktionerne eller datasættene fra en pakke skal den indlæses, hvilket
gøres med kommandoen `library()`.


```{r}
library("isdals")   # Hent data og funktioner fra isdals
```

For at spare på computerens hukommelse bliver installerede pakker kun
indlæst, når brugeren ønsker det. Derfor skal `library()` køres hver gang R
startes op, hvis den pågældende pakke skal
bruges.^[`install.packages()` svarer til, at man installerer en lampe
i et hus --- det behøver man kun at gøre en gang. `library()` svarer
til at tænde på kontakten, og det skal man huske at gøre, hver gang
man starter på noget, og har brug for lyset.]

## Import af data

R kan importere data direkte fra de fleste dataformater og -baser. De
simpleste formater kan indlæses direkte af R, mens mere komplicerede
dataformater kræver, at den relevante pakke er installeret (se tabel
\@ref(tab:importdata) for en oversigt).

Filnavnet angives som første argument, men indlæsningsfunktioner i
tabel \@ref(tab:importdata) har lidt forskellige muligheder alt
afhængigt af dataformatet. Eksempelvis vil følgende kode indlæse
første ark fra Excelfilen `forsøgsdata.xlsx`.^[Filen
`forsøgsdata.xlsx` antages at ligge i samme bibliotek som R
sessionen. Ellers skal den fulde sti til filen skrives.]

```{r eval=FALSE}
library("readxl")
minedata <- read_excel("forsøgsdata.xlsx", sheet=1)
```


Table: (\#tab:importdata) Funktioner og pakker til import af de mest almindelige dataformater i R.

| Filformat (typisk filnavn) | Funktion | Pakke | 
|------------|--------|-----|
|   Tekstfil (`.txt`) | `read.table()` |  |
|   CSV (`.csv`) | `read.csv()`  eller  `read.csv2()` |  |
|   Excel (`.xlsx` eller `.xls`) | `read_excel()` |  `readxl`  |
|   SPSS (`.sav` eller `.por`) | `read_sav()` eller `read_por()` | `haven` |
|   SAS (`.sas7bdat`) | `read_sas()` | `haven` |
|   Stata (`.dta`) | `read_stata()` | `haven` |
|   JSON (`.json`) | `fromJSON()` | `jsonlite` |


RStudio har en indbygget funktion til at importere dataset i
tekstformat. En række almindelige tekstformater kan importeres via
menupunktet `File > Import Dataset`, der hjælper med indlæsningen.
Nedenfor er vist indholdet af en CSV-fil `patienter.csv`.^[En CSV-fil
(comma-separated values) er en almindelig tekstfil, hvor søjlerne i
datasættet er adskilt med comma, semikolon eller mellemrum.]

```
Navn;Alder;Status;BMI;Kon
Jensen;61;1;31,4;M
Hansen;26;0;23;M
Petersen;77;0;28,3;K
Jørgensen;53;1;24,6;K
```

```{r rstudio-import-data, echo=FALSE, fig.cap="Import af data gennem RStudios `File > Import Dataset > From CSV`. Her importeres data fra tekstfilen `patienter.csv`, og nederst er markeret, at søjleadskiller er semikolon. Den lille dialogboks dukker op ved tryk på 'Configure', og her kan man sætte decimaladskiller. Vinduet 'Data preview' viser, hvordan R ser filen med de givne indstillinger, og at det ser fornuftigt ud i dette tilfælde. R finder de fire søjler med de korrekte formater.", out.width="100%", fig.fullwidth=TRUE}
knitr::include_graphics('pics/rstudio-import-data2.png', dpi = NA)
```

Figur \@ref(fig:rstudio-import-data) viser dialogboksen, der
fremkommer, når man vælger `File > Import Dataset > From CSV`. Øverst
vælges den tekstfil, der skal indlæses, og nederst kan man markere, at
første linje i filen indeholder variabelnavnene (`First Row as
Names`), og at variablene (søjlerne i filen) er adskilt med semikolon
(`Delimiter`).

Med knappen "Configure .."  dukker den lille dialogboks
op, hvor man kan angive, at decimaladskiller er komma (det bruges i
filen for variablen `BMI`) og ikke punktum, der er Rs almindelige
decimaladskiller.

Det store vindue "Data preview" viser, hvordan R ser den pågældende
fil med de givne indstillinger. I figur \@ref(fig:rstudio-import-data)
ses det, at data indlæses som fire søjler svarende til de fire
variable i den oprindelige fil, og det ses, at `BMI` er korrekt
indlæst som en double (en numerisk variabel) med de korrekte værdier.
Hvis indlæsningsindstillingerne er sat forkert bliver det klart i
dette vindue, og man får en ide om, hvilke indstillinger der skal
ændres.

Nederst til højre i dialogboksen fremgår de kommandoer, som R kører
for at indlæse filen. Disse kommandoer bør kopieres over i editoren,
for at filen automatisk kan læses korrekt ind en anden gang.^[Dette er
specielt vigtigt for at kunne reproducere resultaterne. Hvis ikke de
præcise argumenter til indlæsning bliver gemt, så risikerer man, at
filen senere indlæses på en anden måde, hvilket kan resultere i
andre resultater. ]


## Avanceret databehandling {#tidyverse}

Data skal ofte tilpasses før de er klar til analyser: der skal laves nye variable, XXX  eller . `tidyverse` er
et sæt af pakker til R, der gør databehandling meget let. Funktionerne
i `tidyverse` arbejder naturligt sammen med Rs data frames (kaldet
`tibbles`\index{tibble} i `tidyverse`) og i funktionerne slipper man
for at skulle referere til variable i data frames med `$`.


, og desuden introduceres operatoren `%>%`,
som kan kæde resultaterne fra flere kommandoer sammen, så de bliver
lettere at læse.^[`%>%` kaldes også en "pipe", da den kan kanalisere resultatet fra en funktion videre til den næste funktion.] Tabel \@ref(tab:tidyversefunctions) viser de mest
almindelige funktioner.

Table: (\#tab:tidyversefunctions) De mest almindelige funktioner til datahåndtering ved hjælp af `tidyverse`.

| Funktion | Forklaring | 
|--------|------------------|
|   `arrange()`  | Sortér data  |
|   `filter()` | Vælg observationer (rækker) |
|   `group_by()` | Split data op i undergrupper |
|   `mutate()`  | Ændre/lav nye variable |
|   `pivot_longer()`  |  Kombiner søjler, så datasættet bliver "langt" |
|   `pivot_wider()`  | Tag to søjler (navne og værdier) og gør data "bredt" |
|   `pull()`  | Udtræk en variabel som en vektor |
|   `select()`  | Vælg søjler (variable) |
|   `summarise()`  | Opsummere data ud fra grupper |
|   `ungroup()`  | Fjern undergrupper |


Til at vise databehandling med `tidyverse` bruger vi et datasæt om
diabetes blandt 768 Pimaindianere. Datasættet hedder
`PimaIndiansDiabetes2` og findes i pakken `mlbench`.^[Husk, at
pakkerne skal installeres før datasættene og funktionerne i dem kan
bruges.] Først indlæses data og de første par linjer vises.

```{r}
library("mlbench")         # Load pakke med data
library("tidyverse")       # Load tidyverse
data(PimaIndiansDiabetes2) # Gør datasæt tilgængeligt
head(PimaIndiansDiabetes2) # Vis de første 6 linjer
```

Vi vil her fokusere på variablene `diabetes`, `age`, `mass` (BMI) og
`pressure` (diastolisk blodtryk). Disse udvælges med `select()`, og da
resultatet skal bruges senere gemmes det i et nyt objekt.^[Vi kan læse udtrykket som følger: "Tag `PimaIndiansDiabetes2` og så udvælges variablene `diabetes`, `age`, `mass` og `pressure` ved hjælp af `select()`". Operatoren `%>%` læses som "og så".]

```{r tidy=FALSE}
pima <- PimaIndiansDiabetes2 %>%
      select(diabetes, age, mass, pressure)
```

Vil vi se nærmere på yngre, svært overvægtige personer, med
BMI>50 og med en alder mindre end 30 år kan vi bruge `filter()` til at udvælge de relevante personer.

```{r}
pima %>% filter(mass>50, age<30)
```

Flere kommandoer kan kombineres ved at bruge `%>%` gentagne
gange. `arrange()` bruges eksempelvis til at sortere efter en eller
flere variable.^[Igen kan udtrykket læses som "Tag datasættet, og så vælg først de rækker, hvor BMI er større end 50 og alder er mindre end 30 år. Og så skal dette resultat efterfølgende sorteres efter blodtryk (fra lav til høj). Vil man have sorteret fra høj til lav bruges `arrange(desc(pressure))`, hvor `desc` henviser til "descending".]

```{r}
pima %>% filter(mass>50, age<30) %>% arrange(pressure)
```

Her er resultatet sorteret efter blodtryk. Nye variable kan defineres
ved at bruge kommandoen `mutate()`. Eksempelvis kan vi lave en ny
variabel, `highbp`, der angiver, om det diastoliske blodtryk er over
90 mmHg ud fra den eksisterende variabel `pressure` i datasættet.

```{r tidy=FALSE}
pima %>% filter(mass>50, age<30) %>%
         mutate(highbp = (pressure>90))
```

`tidyverse` indeholder to andre nyttige funktioner, `summarise()` og
`group_by()`, der henholdsvis bruges til at opsummere data og at splitte
data op i undergrupper for at lave opsummeringer for hver
gruppe. Disse to funktioner introduceres nærmere i kapitel
\@ref(deskstat).

 
## Opgaver

1.  Brug R som lommeregner til at udregne følgende:
    A.  $12\cdot6$
    B.  $2\cdot(1+3)^2$
    C.  $\log(20) + \sqrt{13}$

2.  Definer følgende to vektorer
    ```{r}
    x <- c(1, 3, 6, 2)
    y <- c(10, 20)
    ```
    Overvej --- uden at køre linjerne --- hvad følgende kommandoer i R vil give
    ```{r eval=FALSE}
    x-2
    x^2    
    x+y
    x*y
    length(x)
    sum(x)
    mean(x)
    sum(x^2)
    ```
    Brug R til at checke, om dine overvejelser var korrekte. 

3.  Fødselsvægten (i gram), fostrets alder (i uger) og køn for 8 nyfødte er vist i tabellen nedenfor.

    | Køn | Alder (uge) | Fødselsvægt (g) |
    |-------|-----|-------|
    | dreng   |   37 |   2628 | 
    | dreng   |   38 |   3176 | 
    | dreng   |   40 |   3421 | 
    | dreng   |   38 |   2975 | 
    | dreng   |   40 |   3317 | 
    | pige |   36 |   2729 | 
    | pige |   40 |   2935 | 
    | pige |   38 |   2754 | 

    A.  Lav en vektor `vaegt`, der indeholder de 8 vægtmålinger. Brug for eksempel funktionen `c()`.
    B.  Lav en vektor `alder`, der indeholder aldersmålingerne og en vektor `kon`, der indeholder informationen om køn.
    C.  Udregn en ny vektor, `kg`, der indeholder de afrundede vægtmålinger i kg. Brug funktionen `round()` til at afrunde fødselsvægten til nærmeste 100 gram. 
        Brug hjælpesiden til `round()` til at finde ud af, hvordan man vælger antallet af betydende cifre, når man afrunder.
    D.  De nyfødte piger svarer til måling nummer 6, 7 og 8. Brug indicering af vektoren `vaegt` til at udtrække fødselsvægten for observation 6, 7 og 8. 
        Hvad er den gennemsnitlige fødselsvægt for de tre piger?
        
        Det er sjældent, at man kender de specifikke observationsnumre, man vil udtrække. 
        Brug i stedet oplysningerne fra vektoren `kon` til at udtrække fødselsvægten for pigerne. 
    D.  Lav en data frame, `DF`, der indeholder de 4 variable `kon`, `alder`, `vaegt` og `kg`. Prøv at køre kommandoen 

        ```{r eval=FALSE} 
        head(DF)
        ```
        Hvad viser den? 

        Se hjælpesiden til `head()` for at se, hvordan man ændrer antallet af linjer, der vises.^[`head()` er særlig nyttig, 
        hvis man vil have et hurtigt overblik over indholdet i en data frame eller en vektor.]

        Prøv at køre kommandoen 

        ```{r eval=FALSE}
        summary(DF)
        ```

        Hvad viser den? Hvorfor er formatet forskelligt for `vaegt` og `kon`?

    E.  Erstat det 4. element af `vaegt` i `DF` fra 2975 til værdien 3075.

        Udregn den gennemsnitlige fødselsvægt for alle 8 personer i `DF`.^[Brug enten `$` eller 
        indicering til at trække den relevante variabel ud af data framen.]

7.  Datasættet `morbarn` fra pakken `stat4med` indeholder oplysninger om en tilfældig stikprøve på 400 førstegangsfødende mødre fra det såkaldte Mor-Barn studie XXX, der følger levendefødte børn fra terminsugerne 37-42, og hvor moderen ikke drak under graviditeten. Datasættet indeholder seks registreringer om hver moder: alder (i år), ryger (ja/nej), kaffedrikker (ja/nej), uge (gestationsalder ved fødslen i uger), vaegt (barnets vægt i gram) og længde (barnets længde i cm). 

    De efterfølgende spørgsmål kan med fordel besvare ved brug af funktionerne fra `tidyverse` pakken.

    Data kan indlæses ved at skrive kommandoen 
    ```{r eval=FALSE}
    library("stat4med")  # Indlæs pakken
    data("morbarn")  # Gør data tilgængelige
    ```

    A.  Hvad er gennemsnitsalderen for de 400 førstegangsfødende? Hvad er gennemsnitsvægten for de nyfødte?
    B.  Lav en ny data frame kaldet `deldata`, der kun indeholder de mødre, der hverken ryger eller drikker kaffe.^[Husk, at man skal bruge to lighedstegn, når man checker om en variabel er lig en bestemt værdi.]
    C.  Lav fødselsvægt defineres ofte som børn, der har en fødselsvægt mellem 1500 til 2500 gram. Lav en ny variabel, `lavvaegt`, der er `TRUE`, hvis børnene har lav fødselsvægt, og `FALSE` ellers.
    D.  Hvor mange børn har lav fødselsvægt?^[Man kan bruge funktionen `sum()` til at tælle op, hvor ofte `lavvaegt` er `TRUE`.]
    
    
8.  Hver gang man starter på et nyt projekt er det en god ide at lave
    et bibliotek på computeren, der indeholder alle data og R
    scripts. Det sikrer, at man har data og programmer samlet, og at
    man ikke får sammenblandet filer fra forskellige analyser.

    Når R starter op starter den typisk i samme bibliotek, og det kan
    være nødvendigt at sætte det bibliotek, hvor den skal finde og
    gemme filer.

    A.  Brug funktionen `getwd()` (get working directory) til at se, hvilket bibliotek R leder efter filer i.
    B.  Opret et ny bibliotek, `testR` på computeren. Brug stifinderen til at gøre dette.
    C.  Sæt det nye arbejdsbibliotek til `testR`. Dette kan gøres i RStudio via menupunktet Session -> Set Working Directory -> Choose Directory. Et alternativ er at bruge funktionen `setwd()`.
    D.  Kør `getwd()` igen for at checke at det nye arbejdsbibliotek er `testR`.

5.  Tabeller. Lav en matrix ...

6.  Import af data. CSV? Excel? Ha' en excel-fil på hjemmesiden. Læs den ind, gem som csv. Prøv at læse ind via ...

